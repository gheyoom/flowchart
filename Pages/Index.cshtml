@page
@model IndexModel
@{
    ViewData["Title"] = "Flowchart";
}



<!-- Container for the boxes. Flex-wrap allows them to flow, but we might rely on absolute layout for complex graphs. 
     For now, we keep flex/grid and let lines draw over it. -->
<div class="flow-container" id="flowContainer" dir="rtl" style="height: 1000px; position: relative;">
    @foreach (var box in Model.FlowBoxes)
    {
        <div class="flow-box mb-0" id="box-@box.Id" 
             style="position: absolute; left: @(box.PosX)px; top: @(box.PosY)px; z-index: 10; 
                    background-color: @box.BackgroundColor; border-color: @box.BorderColor; border-style: @box.BorderStyle;
                    @(string.IsNullOrEmpty(box.Width) ? "" : $"min-width: {box.Width};") @(string.IsNullOrEmpty(box.Height) ? "" : $"min-height: {box.Height};")">
            <div class="box-header">
                <h3>@box.Name</h3>
            </div>
            <div class="box-content">
                @if (!string.IsNullOrEmpty(box.Description)) { <div class="text-muted small">@box.Description</div> }
                @if (!string.IsNullOrEmpty(box.DescriptionArabic)) { <div class="fw-bold">@box.DescriptionArabic</div> }
            </div>
            <div class="box-links">
                <div class="link-item text-end">
                    @if (!string.IsNullOrEmpty(box.LinkRightUrl))
                    {
                        <a href="@box.LinkRightUrl" target="_blank" class="flow-link">
                             <i class="bi bi-file-earmark-image"></i> @(box.LinkRightText ?? "Link")
                        </a>
                    }
                </div>
                <div class="link-item text-center">
                    @if (!string.IsNullOrEmpty(box.LinkMiddleUrl))
                    {
                        <a href="@box.LinkMiddleUrl" target="_blank" class="flow-link">
                             <i class="bi bi-file-earmark-text"></i> @(box.LinkMiddleText ?? "Link")
                        </a>
                    }
                </div>
                <div class="link-item text-start">
                    @if (!string.IsNullOrEmpty(box.LinkLeftUrl))
                    {
                        <a href="@box.LinkLeftUrl" target="_blank" class="flow-link">
                            <i class="bi bi-file-earmark-pdf"></i> @(box.LinkLeftText ?? "Link")
                        </a>
                    }
                </div>
            </div>
        </div>
    }
</div>

<!-- Render connections data to JSON for JS to consume -->
<script id="connectionData" type="application/json">
    @Html.Raw(Model.ConnectionJson)
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leader-line/1.0.7/leader-line.min.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        var dataString = document.getElementById('connectionData').textContent;
        var connections = JSON.parse(dataString);


        var lines = [];

        connections.forEach(function(conn) {
            var startElement = document.getElementById(conn.source);
            var endElement = document.getElementById(conn.target);

            if (startElement && endElement) {
                // Map direction
                var startSocket = conn.direction || 'bottom';

                var line = new LeaderLine(
                    startElement,
                    endElement,
                    {
                        color: conn.color || '#000000',
                        size: 3,
                        path: 'grid',
                        startSocket: startSocket,
                        endSocket: 'top'
                    }
                );
                
                if (conn.style === 'dotted') {
                    line.dash = {animation: true};
                } else if (conn.style === 'dashed') {
                    line.dash = {len: 12, gap: 6};
                }
                
                lines.push(line);
            }
        });
        
        window.leaderLines = lines;

        // Reposition lines on scroll/resize
        window.addEventListener('scroll', function() {
            lines.forEach(l => l.position());
        }, {passive: true});
        
         window.addEventListener('resize', function() {
            lines.forEach(l => l.position());
        }, {passive: true});
        
        // Auto-center on Root Node
        // Parse raw connection json again or just find element by text if cleaner... actually we have 'connections' but not boxes data directly in JS var.
        // Let's use DOM lookup for "NDP 01"
        var boxes = document.querySelectorAll('.flow-box h3');
        var rootHeader = Array.from(boxes).find(h => h.innerText.includes("NDP 01"));
        if(rootHeader) {
            var rootEl = rootHeader.closest('.flow-box');
            var container = document.getElementById('flowContainer');
            
            // Calculate center
            var rootRect = rootEl.getBoundingClientRect();
            var containerRect = container.getBoundingClientRect();
            
            // We need relative position inside container
            var rootLeft = parseFloat(rootEl.style.left); 
            var rootWidth = rootEl.offsetWidth;
            
            var viewWidth = container.clientWidth;
            
            // Standard scroll
            window.scrollTo({
                left: rootLeft + (rootWidth/2) - (window.innerWidth/2), 
                behavior: 'smooth'
            });
            // Or if container has overflow
            // But main scroll is body usually.
        }
    });

    function getSocket(dir, type) {
        // Simple mapping. Can be enhanced.
        // dir is e.g. "right". 
        // If dir is "right", source should exit from right, target enter from left?
        // Or strictly user defined? 
        // Let's assume user defined is "Where it leaves source". target socket auto-calculated or opposite?
        
        // Simplified logic:
        // if user says "Right", source exits Right, target enters Left.
        if (!dir) return 'auto';
        dir = dir.toLowerCase();
        
        if (type === 'start') return dir;
        
        // Opposite for end
        if (dir === 'right') return 'left';
        if (dir === 'left') return 'right';
        if (dir === 'top') return 'bottom';
        if (dir === 'bottom') return 'top';
        
        return 'auto';
    }
</script>

<style>
    @@import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap');

    body {
        font-family: 'Cairo', sans-serif;
        background-color: #f8f9fa;
    }

    .flow-container {
        /* display: flex;  -- Removed for canvas layout */
        /* flex-wrap: wrap; */
        /* justify-content: center; */
        /* gap: 4rem; */
        padding: 0;
        position: relative; 
        background-color: #f8f9fa;
        min-height: 800px;
    }

    .flow-box {
        /* position: relative; -- Handled inline */
        background: #fff;
        border: 2px solid #0d6efd;
        border-radius: 8px;
        /* Auto sizing */
        width: fit-content;
        min-width: 250px;
        max-width: 600px; /* Increased to allow more text */
        overflow-wrap: break-word; /* Ensure text wraps */
        
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        display: flex;
        flex-direction: column;
        min-height: 120px;
        z-index: 10; /* Above lines */
        position: relative; 
    }

    .box-header {
        background: #f1f5f9;
        padding: 0.75rem 1.5rem;
        border-bottom: 1px solid #dee2e6;
        border-radius: 6px 6px 0 0;
        text-align: center;
    }

    .box-header h3 {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 700;
        color: #0d6efd;
    }

    .box-content {
        padding: 1rem;
        flex-grow: 1;
        text-align: center;
    }

    .box-links {
        display: flex;
        justify-content: space-between;
        padding: 0.75rem;
        background: #fff;
        border-radius: 0 0 6px 6px;
        border-top: 1px solid #eee;
        gap: 10px;
    }

    .link-item {
        /* flex: 1; removed to let content dictate size */ 
    }
    
    .flow-link {
        text-decoration: none;
        color: #495057;
        font-weight: 600;
        display: inline-block;
        padding: 4px 8px;
        border-radius: 4px;
        transition: color 0.2s;
        font-size: 0.9rem;
    }

    .flow-link:hover {
        background-color: #e9ecef;
        color: #0d6efd;
    }
    
    /* Hide the old CSS arrows since we use LeaderLine */
    .flow-arrow {
        display: none;
    }

    /* Legend Styles */
    .legend-container {
        position: fixed;
        top: 50%; /* Center vertically */
        transform: translateY(-50%);
        left: 10px;
        /* Glassmorphism */
        background: rgba(255, 255, 255, 0.35);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.4);
        box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.2);
        
        border-radius: 8px;
        padding: 0; /* Padding moved to children */
        z-index: 1000;
        direction: rtl;
        text-align: right;
        font-family: 'Cairo', sans-serif;
        max-width: 230px;
        transition: all 0.3s ease;
        overflow: hidden;
    }

    .legend-header {
        padding: 10px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(255,255,255,0.2);
        border-bottom: 1px solid rgba(0,0,0,0.05);
        user-select: none;
    }

    .legend-title-text {
        font-weight: 700;
        font-size: 0.85rem;
    }

    .legend-toggle-icon {
        font-size: 0.8rem;
        transition: transform 0.3s;
    }

    .legend-content {
        padding: 10px;
        transition: all 0.3s ease-in-out;
        max-height: 500px; /* Arbitrary large height for animation */
        opacity: 1;
    }

    /* Collapsed State */
    .legend-container.collapsed {
        max-width: 40px; /* Narrow strip */
        border-radius: 0 8px 8px 0; /* Rounded on right side only */
        left: 0;
    }
    
    .legend-container.collapsed .legend-content {
        max-height: 0;
        opacity: 0;
        padding: 0;
        margin: 0;
        width: 0; /* Hide content width */
        overflow: hidden;
    }
    
    .legend-container.collapsed .legend-header {
        writing-mode: vertical-rl;
        text-orientation: mixed;
        padding: 15px 5px;
        height: auto;
        min-height: 120px;
        justify-content: center;
        gap: 10px;
        border-bottom: none;
    }

    .legend-container.collapsed .legend-title-text {
         transform: rotate(180deg); /* Adjust for Arabic vertical reading if needed, or keep default */
    }
    
    .legend-container.collapsed .legend-toggle-icon {
        transform: rotate(-90deg);
        margin-bottom: 5px;
    }
    
    /* Hover effect for header */
    .legend-header:hover {
        background: rgba(255,255,255,0.4);
    }

    .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
        font-size: 0.7rem;
        color: #222;
        font-weight: 600;
    }

    .legend-box {
        width: 20px;
        height: 14px;
        margin-left: 6px;
        border: 1px solid #000;
        flex-shrink: 0;
    }

    /* Secret */
    .l-secret {
        border: 2px dashed red;
        background: transparent;
    }

    /* Approved */
    .l-approved {
        border: 2px solid black;
        background: white;
    }

    /* Needs Review */
    .l-review {
        border: 1px solid black;
        background: #C1E1C1;
    }

    /* Preparation */
    .l-prep {
        border: 1px solid black;
        background: #FADADD;
    }

    /* Included */
    .l-included {
        border: 1px solid black;
        background: #0070C0;
    }

    /* Authority */
    .l-auth {
        border: 1px solid black;
        background: #FFFF00;
    }

    /* Domain */
    .l-domain {
        border: 1px solid black;
        background: #F4B084;
    }

    /* Translated */
    .l-trans {
        border: 1px solid black;
        background: white;
        position: relative;
    }
    .l-trans::after {
        content: '';
        position: absolute;
        bottom: 1px;
        left: 1px;
        width: 7px;
        height: 7px;
        background: yellow;
        border: 1px solid black;
    }

    /* Summary */
    .l-summary {
        border: 1px solid black;
        background: white;
        text-align: center;
        font-weight: bold;
        line-height: 12px;
        font-size: 9px;
    }
</style>

<div class="legend-container" id="legendContainer">
    <div class="legend-header" onclick="toggleLegend()">
        <span class="legend-title-text">مفتاح الخريطة</span>
        <span class="legend-toggle-icon">▼</span>
    </div>
    <div class="legend-content">
        @foreach (var item in Model.LegendItems)
        {
            <div class="legend-item">
                <div class="legend-box" style="background-color: @item.BackgroundColor; border: @(item.BorderStyle == "dashed" ? "2px dashed" : item.BorderStyle == "dotted" ? "2px dotted" : "1px solid") @item.BorderColor;">
                     @if(item.Title.Contains("Summary")) { <span>S</span> }
                </div>
                <span>@item.Title</span>
            </div>
        }
    </div>
</div>

<script>
    function toggleLegend() {
        var el = document.getElementById('legendContainer');
        el.classList.toggle('collapsed');
        var icon = el.querySelector('.legend-toggle-icon');
        // Icon rotation is handled by CSS mostly, but let's just stick to one char or remove the char change if we rely on rotation.
        // Let's keep it simple: Arrow Left when collapsed (pointing into screen), Arrow Down when open.
        if(el.classList.contains('collapsed')) {
             icon.innerText = '◀'; 
        } else {
             icon.innerText = '▼';
        }
    }

    // --- Zoom Logic ---
    var currentScale = 1;
    var container = document.getElementById('flowContainer');
    // We need to fetch all boxes to determine bounding box for perfect fit
    // But simplistic approach: Scale based on width.

    function setScale(scale) {
        currentScale = scale;
        // transform-origin 0 0 allows us to scale from top-left, making layout easier to control with scrolling
        container.style.transformOrigin = '50% 0'; 
        container.style.transform = 'scale(' + currentScale + ')';
        document.getElementById('zoomLevel').innerText = Math.round(currentScale * 100) + '%';
        
        // Update lines
        if(window.leaderLines) { 
             window.leaderLines.forEach(l => l.position()); 
        }
        // Force redraw lines effectively after transition
        setTimeout(() => { if(window.leaderLines) window.leaderLines.forEach(l => l.position()); }, 100);
    }

    function zoomIn() {
        setScale(currentScale + 0.1);
    }

    function zoomOut() {
        if(currentScale > 0.2) setScale(currentScale - 0.1);
    }

    function resetZoom() {
        fitToScreen();
    }

    function fitToScreen() {
        // Calculate required scale
        // Find max X of boxes
        var maxRight = 0;
        var boxes = document.querySelectorAll('.flow-box');
        boxes.forEach(b => {
             var right = b.offsetLeft + b.offsetWidth;
             if(right > maxRight) maxRight = right;
        });

        // Add some margin
        maxRight += 100;

        var availableWidth = window.innerWidth - 40; // margins
        var scale = availableWidth / maxRight;
        
        // Clamp scale
        if(scale > 1) scale = 1; 
        if(scale < 0.2) scale = 0.2;
        
        setScale(scale);
    }

    // Init Fit to Screen
    document.addEventListener("DOMContentLoaded", function() {
        // Wait slightly for layout
        setTimeout(fitToScreen, 100);
    });
</script>

<!-- Zoom Controls -->
<div class="zoom-controls">
    <button onclick="zoomIn()" class="btn btn-light btn-sm" title="Zoom In">+</button>
    <button onclick="resetZoom()" class="btn btn-light btn-sm" title="Fit to Screen/Reset">
        <span id="zoomLevel">100%</span>
    </button>
    <button onclick="zoomOut()" class="btn btn-light btn-sm" title="Zoom Out">-</button>
</div>

<style>
   .zoom-controls {
       position: fixed;
       bottom: 20px;
       right: 20px;
       display: flex;
       flex-direction: column;
       gap: 5px;
       background: rgba(255,255,255,0.8);
       backdrop-filter: blur(5px);
       padding: 8px;
       border-radius: 8px;
       border: 1px solid rgba(0,0,0,0.1);
       z-index: 1001;
       box-shadow: 0 4px 6px rgba(0,0,0,0.1);
   }
   
   .zoom-controls button {
       width: 40px;
       font-weight: bold;
       border: 1px solid #ccc;
   }
</style>
